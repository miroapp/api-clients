/**
 * Miro API
 * Miro API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import fetch, {Response} from 'node-fetch';
import * as http from 'http';

/* tslint:disable:no-unused-locals */
import { BoardChanges } from '../model/boardChanges';
import { BoardWithLinks } from '../model/boardWithLinks';
import { BoardsPagedResponse } from '../model/boardsPagedResponse';
import { GetBoards400Response } from '../model/getBoards400Response';

import { ObjectSerializer } from '../model/models';

import { HttpError } from './apis';

let defaultBasePath = 'https://api.miro.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export interface BoardsApiMethods {
    /**
     * Creates a copy of an existing board. You can also update the name, description, sharing policy, and permissions policy for the new board in the request body.<br/><h3>Required scope</h3> <a target=\"blank\" href=\"/reference/scopes\">boards:write</a> <br/><h3>Rate limiting</h3> <a target=\"blank\" href=\"/reference/ratelimiting\">Level 4</a><br/>
     * @summary Copy board
     * @param copyFrom [Unique identifier (ID) of the board](https://developers.miro.com/reference/board-model) that you want to copy.
     * @param boardChanges 
     */
    copyBoard(copyFrom: string, 

 
boardChanges?: BoardChanges,

): Promise<{ response: Response; body: BoardWithLinks;  }>
    /**
     * Creates a board with the specified name and sharing policies.<br/><h3>Required scope</h3> <a target=\"blank\" href=\"/reference/scopes\">boards:write</a> <br/><h3>Rate limiting</h3> <a target=\"blank\" href=\"/reference/ratelimiting\">Level 3</a><br/>
     * @summary Create board
     * @param boardChanges 
     */
    createBoard(

 
boardChanges?: BoardChanges,

): Promise<{ response: Response; body: BoardWithLinks;  }>
    /**
     * 
     * @summary Delete board
     * @param boardId [Unique identifier (ID) of the board](https://developers.miro.com/reference/board-model) that you want to delete.
     */
    deleteBoard(boardId: string, 
): Promise<{ response: Response; body: object;  }>
    /**
     * Retrieves a list of boards that match the search criteria provided in the request. If you are an Enterprise customer and a Company Admin, you can retrieve all boards, including all private boards (boards that haven\'t been specifically shared with you) by enabling Content Admin permissions. To enable Content Admin permissions, see https://help.miro.com/hc/en-us/articles/360012777280-Content-Admin-permissions-for-Company-Admins. Note that you only get results instantaneously when you filter by `team_id`. If you use any other filter,  you need to give a few seconds for the indexing of newly created boards before retrieving boards.<br/><h3>Required scope</h3> <a target=\"blank\" href=\"/reference/scopes\">boards:read</a> <br/><h3>Rate limiting</h3> <a target=\"blank\" href=\"/reference/ratelimiting\">Level 1</a><br/>
     * @summary Get boards
     * @param teamId 
     * @param query 
     * @param owner 
     * @param limit 
     * @param offset 
     * @param sort 
     */
    getBoards(
 query?: { 

teamId?: string,
 


query?: string,
 


owner?: string,
 


limit?: string,
 


offset?: string,
 


sort?: 'default' | 'last_modified' | 'last_opened' | 'last_created' | 'alphabetically',
 },  
): Promise<{ response: Response; body: BoardsPagedResponse;  }>
    /**
     * Retrieves information about a board.<br/><h3>Required scope</h3> <a target=\"blank\" href=\"/reference/scopes\">boards:read</a> <br/><h3>Rate limiting</h3> <a target=\"blank\" href=\"/reference/ratelimiting\">Level 1</a><br/>
     * @summary Get specific board
     * @param boardId [Unique identifier (ID) of the board](https://developers.miro.com/reference/board-model) that you want to retrieve.
     */
    getSpecificBoard(boardId: string, 
): Promise<{ response: Response; body: BoardWithLinks;  }>
    /**
     * 
     * @summary Update board
     * @param boardId [Unique identifier (ID) of the board](https://developers.miro.com/reference/board-model) that you want to update.
     * @param boardChanges 
     */
    updateBoard(boardId: string, boardChanges: BoardChanges, 
): Promise<{ response: Response; body: BoardWithLinks;  }>
}

export function BoardsApi (accessToken: string|(() => Promise<string>), basePath: string = defaultBasePath, logger?: (...thing: any) => void): BoardsApiMethods {
    return {

        /*
        */

        copyBoard: async function (copyFrom: string, 

 
boardChanges?: BoardChanges,

) : Promise<{ response: Response; body: BoardWithLinks;  }> {
            const localVarPath = '/v2/boards';
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }



                // verify required parameter 'copyFrom' is not null or undefined
                if (copyFrom === null || copyFrom === undefined) {
                    throw new Error('Required parameter copyFrom was null or undefined when calling copyBoard.');
                }


            if (copyFrom !== undefined) {
                localVarQueryParameters.append('copy_from', ObjectSerializer.serialize(copyFrom, "string"));
            }


            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
                body: JSON.stringify(ObjectSerializer.serialize(boardChanges, "BoardChanges"))
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "BoardWithLinks");

            return({response, body})
        },

        /*
        */

        createBoard: async function (

 
boardChanges?: BoardChanges,

) : Promise<{ response: Response; body: BoardWithLinks;  }> {
            const localVarPath = '/v2/boards';
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }



            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
                body: JSON.stringify(ObjectSerializer.serialize(boardChanges, "BoardChanges"))
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "BoardWithLinks");

            return({response, body})
        },

        /*
        */

        deleteBoard: async function (boardId: string, 
) : Promise<{ response: Response; body: object;  }> {
            const localVarPath = '/v2/boards/{board_id}'
                .replace('{' + 'board_id' + '}', encodeURIComponent(String(boardId)));
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }

            // verify required parameter 'boardId' is not null or undefined
            if (boardId === null || boardId === undefined) {
                throw new Error('Required parameter boardId was null or undefined when calling deleteBoard.');
            }



            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "object");

            return({response, body})
        },

        /*
        */

        getBoards: async function (
 query?: { 

teamId?: string,
 


query?: string,
 


owner?: string,
 


limit?: string,
 


offset?: string,
 


sort?: 'default' | 'last_modified' | 'last_opened' | 'last_created' | 'alphabetically',
 },  
) : Promise<{ response: Response; body: BoardsPagedResponse;  }> {
            const localVarPath = '/v2/boards';
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }




            if (query?.teamId !== undefined) {
                localVarQueryParameters.append('team_id', ObjectSerializer.serialize(query?.teamId, "string"));
            }



            if (query?.query !== undefined) {
                localVarQueryParameters.append('query', ObjectSerializer.serialize(query?.query, "string"));
            }



            if (query?.owner !== undefined) {
                localVarQueryParameters.append('owner', ObjectSerializer.serialize(query?.owner, "string"));
            }



            if (query?.limit !== undefined) {
                localVarQueryParameters.append('limit', ObjectSerializer.serialize(query?.limit, "string"));
            }



            if (query?.offset !== undefined) {
                localVarQueryParameters.append('offset', ObjectSerializer.serialize(query?.offset, "string"));
            }



            if (query?.sort !== undefined) {
                localVarQueryParameters.append('sort', ObjectSerializer.serialize(query?.sort, "'default' | 'last_modified' | 'last_opened' | 'last_created' | 'alphabetically'"));
            }


            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "BoardsPagedResponse");

            return({response, body})
        },

        /*
        */

        getSpecificBoard: async function (boardId: string, 
) : Promise<{ response: Response; body: BoardWithLinks;  }> {
            const localVarPath = '/v2/boards/{board_id}'
                .replace('{' + 'board_id' + '}', encodeURIComponent(String(boardId)));
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }

            // verify required parameter 'boardId' is not null or undefined
            if (boardId === null || boardId === undefined) {
                throw new Error('Required parameter boardId was null or undefined when calling getSpecificBoard.');
            }



            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "BoardWithLinks");

            return({response, body})
        },

        /*
        */

        updateBoard: async function (boardId: string, boardChanges: BoardChanges, 
) : Promise<{ response: Response; body: BoardWithLinks;  }> {
            const localVarPath = '/v2/boards/{board_id}'
                .replace('{' + 'board_id' + '}', encodeURIComponent(String(boardId)));
            let localVarQueryParameters = new URLSearchParams();
            let localVarHeaderParams: Record<string, string> = {}
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            } else {
                localVarHeaderParams.Accept = produces.join(',');
            }

            // verify required parameter 'boardId' is not null or undefined
            if (boardId === null || boardId === undefined) {
                throw new Error('Required parameter boardId was null or undefined when calling updateBoard.');
            }



            const resource = new URL(localVarPath, basePath)
            resource.search = localVarQueryParameters.toString()


const options = {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${typeof accessToken === 'function' ? await accessToken() : accessToken}`
                },
                body: JSON.stringify(ObjectSerializer.serialize(boardChanges, "BoardChanges"))
            }

            if (typeof logger === 'function') logger('FETCH', resource.toString(), options)

            const response = await fetch(resource, options)

            if (typeof logger === 'function') logger('RESPONSE', response)

            let bodyAsJson: unknown
            try {
                bodyAsJson = await response.json()
            } catch (err) {
                // Body doesn't have valid json
            }

            if (typeof logger === 'function' && bodyAsJson) logger('BODY', bodyAsJson)

            if (!response.ok) {
                throw new HttpError(response, bodyAsJson, response.status)
            }

            const body = ObjectSerializer.deserialize(bodyAsJson, "BoardWithLinks");

            return({response, body})
        },
    }
}
